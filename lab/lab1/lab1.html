
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>ECE383</title>
        <meta name="description" content="ECE 383 - Embedded Systems II with the Digilent Atlys at the United States Air Force Academy (USAFA).  Covers VHDL.  Free and open FPGA course.">
        <meta name="author" content="Todd Branchflower">
        <link rel='stylesheet' type='text/css' href='//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css'>
        <script src='//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js'></script>
		<META HTTP-EQUIV="refresh" CONTENT="1200"> <!--added this line to force page refresh every 1200 seconds-->
    </head>
    <body>

        <div class = "container">
            <div class = "navbar navbar-inverse">
                <div class = "navbar-inner">
                    <a class = "brand" href="../../index.html">ECE383</a>
                    <ul class="nav pull-right">
                        <li><a href="../lab2/lab2.html">Next&gt</a></li>
                    </ul>
                </div>
            </div>

<table class="table table-striped table-bordered table-condensed">
<tr><td>Start date:</td>	<td>January  19/20</td></tr>
<tr><td>End date:</td>		<td>January  27/28</td></tr>
<tr><td>Lab:</td>		<td>1</td></tr>
<tr><td>Status		<td bgcolor = #D0FFD0>Complete <!--<td bgcolor = #FFFFF0>Not Started --> <!--<td bgcolor = #FFD0D0>In Progress -->
<tr><td>Lab 1 Cutsheet<td><a href="./ECE_383_Lab1_Cutsheet.pdf">ECE_383_Lab1_Cutsheet.pdf</a>
<tr><td>Lab 1 Supplemental PowerPoint<td><a href="./ECE383_Lab1Supplement.pptx">Lab 1 Supplement and Clock Tutorial.pptx</a>
<tr><td>Lab 1 Editable Block Diagram<td><a href="./ECE383_Lab1_Block_Diagram.pptx">ECE383_Lab1_Block_Diagram.pptx</a>
</table>


<h1>Lab 1 - Video Synchronization</h1>

<h2>Lab Overview</h2>
In this lab, you will write a VGA controller in VHDL and implement 
it on your FPGA development board.  You will be provided a VGA-to-HDMI 
module that will automatically format your output for the HDMI output 
port on your development board.  This VGA controller will be tasked 
to generate the display portion of an oscilloscope as shown in the
figure below.  The scope face consists of a white grid, used to 
measure the signals, two trigger markers, and the waveforms. 
The grid shall contain 11 vertical lines and 9 horizontal lines.
 In this lab, the waveforms will be artificially generated by your code,
but in later labs, the waveforms will be generated by incoming
audio waveforms.

<br><img src="./img/layout.jpg" alt="Figure 3"><br><br>

<h2>VGA Overview</h2>
Video Graphics Array (VGA) is an interface protocol used to transmit 
analog video data to a screen.  The VGA protocol uses a scanning method 
to project an image on the screen.  Starting in the top-left of the 
screen, the monitor will progressively move from left to right, top 
to bottom to display each pixel.  The following signals must be sent 
to a VGA monitor in order to display an image.

<ol>
<li><code>red</code>, <code>green</code>, <code>blue</code> - three 
separate analog voltage signals indicating the amount of each color 
to display in the current pixel.  These signals are sometimes 
abbreviated as RGB.</li>
<li><code>h_sync</code> - Horizontal synchronization signal that tells 
the screen to start writing pixels to the next line</li>
<li><code>v_sync</code> - Vertical synchronization signal that tells 
the screen that the current video frame is completed.  The screen then 
starts writing pixels to the top-left of the screen.</li>
</ol>

Both synchronization signals contain four unique states: 
<code>active_video</code>, <code>front_porch</code>, 
<code>sync_pulse</code>, and <code>back_porch</code>.  Incoming pixel 
data (through the RGB channels) is only displayed during the active_video 
state of the synchronization signals.<br><br>

Internally, you will use a 25MHz clock as your <code>pixel_clk</code>.  
On the rising edge of this clock, when both the <code>h_sync</code> and 
<code>v_sync</code> signals are in the active_video state, you will place 
the RGB values you want the screen to display for that pixel.  During all 
other states, the RGB values must be &quot;0&quot;.

<br><img width = 800 src="./img/figure1.jpg" alt="Figure 1"><br><br>

<strong>Figure 1</strong>: The <code>h_sync</code> signal contains four 
states.  Pixel data is only displayed on the monitor during the 
active_video state.  During all other state, the RGB values must be 
&quot;0&quot;.<br><br>

The <code>v_sync</code> signal looks nearly identical to the 
<code>h_sync</code> signal, however it is significantly stretched out 
in time.  Where the <code>h_sync</code> signal was counted in terms of 
<code>pixel_clk</code>, the <code>v_sync</code> signal is counted based 
on iterations of the <code>h_sync</code> signal.  For example, in 
Figure 2, the <code>active_video</code> portion is active for 480 
complete iterations of the <code>h_sync</code> signal.<br><br>

<br><img width = 800 src="./img/figure2.jpg" alt="Figure 2"><br><br>

<strong>Figure 2</strong>: The <code>v_sync</code> signal is similar 
to <code>h_sync</code>, but instead of counting based on 
<code>pixel_clk</code>, the states are based on the number of iterations 
of the <code>h_sync</code> signal.  Pixel data is only displayed on the 
monitor during the active_video state.  During all other state, the RGB 
values must be &quot;0&quot;.<br><br>

More details on the VGA protocol can be found at 
<a href="https://web.mit.edu/6.111/www/labkit/vga.shtml#:~:text=The%20RGB%20input%20signals%20can%20be%20overridden,and%20blank%20signals:%20The%20active%20low%20blank&text=VGA%20Timings.%20The%20following%20table%20lists%20timing%20values%20for%20several">http://www-mtl.mit.edu/Courses/6.111/labkit/vga.shtml</a>.  
This link provides the exact numbers needed to generate the correct 
timing pulse signals for any VGA resolution. And this youtube video illustrates how the old CRT works: 
<a href="https://m.youtube.com/watch?v=3BJU2drrtCM"> 
How a TV Works in Slow Motion - The Slow Mo Guys </a>. 

<h2>VHDL Code</h2>
In order to get you going in this lab, some of the VHDL code has been 
provided for you. In most cases, you should refrain from changing the
modules given.  In order to get a better understanding how these modules 
interact with one another, the following section provides a schematic
and the input, output and behavior of some of the modules.

<ul>	<li><a href="./code/lab1.vhdl">lab1.vhdl</a>
	<li><a href="./code/Lab1.xdc">lab1.xdc</a>
	<li><a href="./code/video.vhdl">video.vhdl</a>
	<li><a href="./code/vga_tb.vhdl">vga_tb.vhdl</a>
	<li><a href="./code/dvid.vhdl">dvid.vhdl</a>
	<li><a href="./code/tdms.vhdl">tdms.vhdl</a>
	<li>All this code is in this ZIP file: <a href="./code/lab1_cadet_code.zip">lab1_cadet_code.zip </a>

</ul>


<h2>Architecture</h2>
The design of Lab 1 is broken down into separate modules, some of which
are provided for you and some which you will need to create.  The
interconnection of the modules is illustrated in the following schematic.
When a signal name appears just inside a box, that should should correspond
to the name of that signal in the entity description.  Please note
there are a few omissions in the diagram that you should correct
as part of your documentation (see Turn-In section).

<br><img src="./img/architecture.jpg"><br><br>

There are two modules which will constitute the majority of your work, VGA
and scopeFace.  The following two subsections details the behavior of these
two modules.

<h3>The VGA module</h3>
Your main task is to build the VGA component for Lab1.  This component 
sweeps across the display from left to right, and then return to the 
left side of the next lower row.  The VGA interface determines the color
of each pixel on this journey with the help of the scopeFace component.

<pre>
entity vga is
	Port(	clk: in  STD_LOGIC;
			reset_n : in  STD_LOGIC;
			h_sync : out  STD_LOGIC;
			v_sync : out  STD_LOGIC; 
			blank : out  STD_LOGIC;
			r: out STD_LOGIC_VECTOR(7 downto 0);
			g: out STD_LOGIC_VECTOR(7 downto 0);
			b: out STD_LOGIC_VECTOR(7 downto 0);
			trigger_time: in unsigned(9 downto 0);
			trigger_volt: in unsigned (9 downto 0);
			row: out unsigned(9 downto 0);
			column: out unsigned(9 downto 0);
			ch1: in std_logic;
			ch1_enb: in std_logic;
			ch2: in std_logic;
			ch2_enb: in std_logic);
end vga;
</pre>

<table class="table table-striped table-bordered table-condensed">
<tr><td>clk	<td>This is the 25Mhz pixel clock generated by the DCM in 
			the video module.
<tr><td>reset_n	<td>This is the same active high reset signal passed into the top
			level Lab1 module.
<tr><td>tr_volt	<td>This is a 10-bit unsigned value representing the trigger 
			voltage.  This value is passed to the scopeFace module
			so that a yellow arrow (see Trigger Level Marker in the
			screen show) on the vertical axis.
<tr><td>tr_time	<td>This is a 10-bit unsigned value representing the trigger 
			time.  This value is passed to the scopeFace module
			so that a yellow arrow (see Trigger Time Marker in the
			screen show) on the horizontal axis.
<tr><td>ch1	<td>This 1-bit signal signals the VGA module to draw the channel
			1 signal on the scope for this row, column pixel.
			When the value is 1, draw a yellow pixel on
			the display at the current row,colum position.  When 0, 
			do not draw a pixel.
<tr><td>ch1_enb	<td>This 1-bit signal enable the ch1 signal to be drawn.
<tr><td>ch2	<td>This 1-bit signal signals the VGA module to draw the channel
			2 signal on the scope for this row,column pixel.
			When the value is 1, draw a green pixel on
			the display at the current row, column position.  When 0, 
			do not draw a pixel.
<tr><td>ch2_enb	<td>This 1-bit signal enable the ch2 signal to be drawn.
<tr><td>R	<td>The 8-bit red intensity for this row,column pixel on the 
			screen.
<tr><td>G	<td>The 8-bit green intensity for this row,column pixel on the 
			screen.
<tr><td>B	<td>The 8-bit blue intensity for this row,column pixel on the 
			screen.
<tr><td>Row	<td>The current row being drawn on the display.
<tr><td>Column	<td>The current row being drawn on the display.
<tr><td>blank	<td>The blank signal for the current row,column position.  Its
			the logical OR of the h_blank and v_blank signals.
<tr><td>h_synch	<td>The h_synch signal for the current row,column position.
<tr><td>v_synch	<td>The v_synch signal for the current row,column position.
<tr><td>Behavior<td>

The VGA component contains a pair of cascaded counters which generate the 
row and column values of the current pixel being displayed.  The row and
column values are used to generate the blank, h_synch and v_synch signals 
according to the Figures above.  The scopeFace component (more on this below),
takes the row and column values (along with some other information) and 
generates the R,G,B color of that pixel.  The three muxes on the output
of the R,G,B output of the scopeFace component output the scopeFace R,G,B
values for row,column values within the 640x480 displayable region,
or 0's for values outside this region.
</table>



<h3>The scopeFace module</h3>
Inside the VGA module sits an instance of the scopeFace entity.  This entity 
only contains combinational logic.  When given a row,column pair, its responsible
for generating the R,G,B value of that pixel.

<pre>
entity scopeFace is
    Port ( row : in  unsigned(9 downto 0);
           column : in  unsigned(9 downto 0);
			  trigger_volt: in unsigned (9 downto 0);
			  trigger_time: in unsigned (9 downto 0);
           r : out  std_logic_vector(7 downto 0);
           g : out  std_logic_vector(7 downto 0);
           b : out  std_logic_vector(7 downto 0);
			  ch1: in std_logic;
			  ch1_enb: in std_logic;
			  ch2: in std_logic;
			  ch2_enb: in std_logic);
end scopeFace;
</pre>

<table class="table table-striped table-bordered table-condensed">
<tr><td>clk	<td>This is the 25Mhz pixel clock generated by the DCM in 
			the video module.
<tr><td>reset_n	<td>This is the same active high reset signal passed into the top
			level Lab1 module.
<tr><td>tr_volt	<td>This is a 10-bit unsigned value representing the trigger 
			voltage.  This value is passed to the scopeFace module
			so that a yellow arrow (see Trigger Level Marker in the
			screen show) on the vertical axis.
<tr><td>tr_time	<td>This is a 10-bit unsigned value representing the trigger 
			time.  This value is passed to the scopeFace module
			so that a yellow arrow (see Trigger Time Marker in the
			screen show) on the horizontal axis.
<tr><td>ch1	<td>This 1-bit signal signals the VGA module to draw the channel
			1 signal on the scope for this row, column pixel.
			When the value is 1, draw a yellow pixel on
			the display at the current row,column position.  When 0, 
			do not draw a pixel.
<tr><td>ch1_enb	<td>This 1-bit signal enable the ch1 signal to be drawn.
<tr><td>ch2	<td>This 1-bit signal signals the VGA module to draw the channel
			2 signal on the scope for this row,column pixel.
			When the value is 1, draw a green pixel on
			the display at the current row, column position.  When 0, 
			do not draw a pixel.
<tr><td>ch2_enb	<td>This 1-bit signal enable the ch2 signal to be drawn.
<tr><td>R	<td>The 8-bit red intensity for this row,column pixel on the 
			screen.
<tr><td>G	<td>The 8-bit green intensity for this row,column pixel on the 
			screen.
<tr><td>B	<td>The 8-bit blue intensity for this row,column pixel on the 
			screen.
<tr><td>Row	<td>The current row being drawn on the display.
<tr><td>Column	<td>The current row being drawn on the display.
<tr><td>Behavior<td>
The scopeFace component takes in the current row,column coordinates of the 
display and generates the R,G,B values at that screen coordinate. For example,
if row,column = 20,20 then the R,G,B output should be 0xFF,0xFF,0xFF (white)
because the upper left corner of the O'scope grid display is white.  Note,
you can get the RGB values for common colors at 
<a href="http://www.w3schools.com/colors/colors_names.asp">this</a> web site.
</table>

<h2>Connecting</h2>
Your Digilent board will have a lot of connections required to make
this lab work.  The image below shows how I made these connections to
get the lab to work.
<br><img src="./img/board.jpg"><br><br>

<h2>Gate Checks</h2>
There are 2 gate checks associated with this lab, each worth 5 points - see the rubric below. This year we will use Gradescope to track when you complete the milestones.
<h3>Gate Check 1</h3>
By COB Lesson 6, you  must have finished setting up the VGA counters to generate the proper 
rows and columns on the waveform.  This can be shown with waveform screenshots from the VGA testbench 
showing the h count rolling over causing the v count to increment.  Be sure to also show both max counts.
You must implement the two counters similar to the method implemented for the counters in Homework 4.
<ul>
	<li>Show both the row and column max counts rolling over back to zero
	<li>Show the roll signal between the column counter rollover to the row counter, making the row counter count up.
	<li>
</ul>
<h3>Gate Check 2</h3>
By COB Lesson 7, you must have setup the appropriate v_synch, v_blank, h_synch, and h_blank 
signals on the waveform and created the scopeFace module to draw at least one line on the display. Include 
picture of the line on the display and associated .bit file for the scopeFace module proof.  Additionally, 
include screenshots of waveforms showing:
<ul>
	<li>Show the h_synch going high, low, and high in relation to column count.
	<li>Show the v_synch going high, low, and high in relation to row count.
	<li>Show the blank signals going high, low, and high in relation to column count and row count.
</ul> 
Upload these products to bitbucket. Demo can be live to your instructor or an image uploaded to bitbucket.

<h2>Required Functionality</h2>
For Required Functionality your code must generate the white oscilloscope grid pattern shown 
in the Figure above and draw the two channels of traces.  
To test this draw:
<ul>
	<li>The channel 1 trace (yellow) along a diagonal where (row = column).
	<li>The channel 2 trace (green) should be drawn along a diagonal where
(row = 440-column). 
	<li>Switch(0) should be able to enable and disable channel 1
	<li>Switch(1) should be able to enable and disable channel 2
	<li>This test code should be placed in the Lab1 entity.
</ul>
Upload these products to bitbucket. You need to draw the channel 1 trace (yellow) along a diagonal where (row = column).
The channel 2 trace (green) should be drawn along a diagonal where
(row = 440-column).  This test code should be placed in the Lab1
entity (not in scopeface).  Demo can be live to your instructor or a video uploaded to Streams.


<h2>A-level functionality</h2>
A-level functionality is shown in the Figure in the Lab Overview
section at the top of the page.  In addition to drawing the display, the
display must update when one of the buttons is pressed according to
the list below.

<ul>
<li>Pressing the 
upper directional button (BTNU) once should move the Trigger Level Marker up.
<li>Pressing the 
lower directional button (BTND) once should move the Trigger Level Marker down.
<li>Pressing the 
left  directional button (BTNL) once should move the Trigger Time Marker left.
<li>Pressing the 
right  directional button (BTNR) once should move the Trigger Time Marker right.
</ul>
In order to achieve this level of functionality, you will need to implement
the two Process blocks in the Lab1 entity in the schematic.  These buttons do
not need to be "debounced."  However, if you debounce your buttons properly you can earn 3 bonus points.
<br><br>
You can earn another 3 bonus points for demonstrating you can create the timing for the HDMI format in addition to the VGA format.
You would still do the lab with the VGA specs (and scopeface assuming a 640x480 screen),
but then slightly modify your clock_wiz, counters, horz_sync, vert_sync, blank to make one of the HDMI formats work (like 1280x720 or 1920x1080).
You DO NOT need to update your scopeface (so your current grid will appear tiny on the upper left corner of the monitor).
Warning: we haven't attempt this yet... You will be the first!
See the table at this link for the HDMI specs: <a href="https://web.mit.edu/6.111/www/labkit/vga.shtml#:~:text=The%20RGB%20input%20signals%20can%20be%20overridden,and%20blank%20signals:%20The%20active%20low%20blank&text=VGA%20Timings.%20The%20following%20table%20lists%20timing%20values%20for%20several">http://www-mtl.mit.edu/Courses/6.111/labkit/vga.shtml</a>.  


<br><br>

Upload these products to bitbucket. Demo can be live to your instructor or a video uploaded to Streams.

<h2>Turn In</h2>
All your work in this lab is to be uploaded to Bitbucket and you will make submission in Gradescope to record the time each milestone is completed.  The main part of the
lab is your README, documenting your design.  The README can be in markdown, word, or a pdf, and should be uploaded to bitbucket.
Your README must include the following:

<ul>
<li><strong>Introduction</strong> - Provide a brief overview of the 
problem.</li>

<li><strong>Design/Implementation</strong> - Include your diagrams from HW#5.  Provide the block-diagram of your 
solution using the <strong>signal names in your code</strong>.  The
block diagram given above is somewhat incomplete, <strong>make sure to include
corrections to this diagram</strong>.  An editable block diagram PPT is provided 
at the top of the page.  For each module that you built, explain
its overall purpose, inputs, outputs, and behavior.  You do not need to include code in this report 
(instead put all your vhdl files (code and testbench), wcfg file, and bit files in bitbucket) </li>

<li><strong>Test/Debug</strong> - Briefly describe the methods used 
to verify system functionality  (such as products from gate check 1 and 2).
  Show at least three excerpts from your 
testbench for the VGA module (as screen shots):
<ul type="a">
	<li>Show the h_synch going high, low, and high in relation to column count.  
	<li>Show the v_synch going high, low, and high in relation to row count.  
	<li>Show the blank signals going high, low, and high in relation to column count and row count.
	<li>Show the column count rolling over causing the row count to increment and 
max counts for both counters.

</ul>

List the major problems you encountered and how you fixed them.  
This should cover all the problems you encountered in the lab and 
how you fixed them.  Break each problem and solution into separate 
paragraphs.</li>

<li><strong>Results</strong> - This section should clearly state for 
each milestone/functionality the date/time it was achieved, level of achievement 
(e.g, achieved, partially-achieved, not achieved), what was achieved, and 
evidence you proved it worked (e.g., via demo or images/videos).

We no longer use the printed lab cutsheets
signed by your instructor as you meet each milestone, but instead have you make a submission in Gradescope for each milestone. 
For example, you could have entries like this:

<table class="table table-striped table-bordered">
<thead>
<tr>
<th align="center">Milestone</th>
<th align="center">Date/Time</th>
<th align="center">What was achieved</th>
</tr>
</thead>
<tbody>

<tr>
<td align="center" colspan="1">Gate Check 1</td>
<td align="center" colspan="1"></td>
<td align="center" colspan="1">Achieved: Demo'd to instructor, showing testbench simulation plot of the VGA counters generating the proper rows and columns. See testbench1.jpg and discussion in test/debug section of README (report) on bitbucket. </td>
</tr>

<tr>
<td align="center" colspan="1">Gate Check 2</td>
<td align="center" colspan="1"></td>
<td align="center" colspan="1">Achieved: Demo'd to instructor, showing testbench simulation plot showing proper generation of h_sync, h_count, v_sync, and v_count, and demo'd live program plotting the scopeface grid and a yellow ch1 line on the monitor.
 See testbench2.jpg, monitor_image1.jpg and discussion in test/debug section </td>
</tr>

<tr>
<td align="center" colspan="1">Required Functionality</td>
<td align="center" colspan="1"></td>
<td align="center" colspan="1">Achieved: Demo'd to instructor live program with o'scope grid pattern generated on the monitor, ch1 with a yellow diagonal line and ch2 with a green diagonal line. Demo'd ability to enable and disable ch1 and ch2 with switches.  See monitor_image2.jpg in the README (report) on bitbucket.</td>
</tr>

<tr>
<td align="center" colspan="1">A Functionality</td>
<td align="center" colspan="1"></td>
<td align="center" colspan="1">Partially Achieved. The up/down button move the trigger level marker up and down properly, but the left/right buttons do not work. See video1.mov (link)</td>
</tr>
</tbody>
</table>


</li>

<li><strong>Conclusion</strong> - Explain what your learned from this 
lab and what changes you would recommend in future years to this lab 
or the lectures leading up to this lab.</li>
</ul>

<h2>Grading - Lab 1</h2>
<table class="table table-striped table-bordered">
<thead>
<tr>
<th align="center">Item</th>
<th align="center">Points</th>
</tr>
</thead>
<tbody>

<tr>
<td align="center" colspan="1">Gate Check 1</td>
<td align="center" colspan="1">5</td>
</tr>

<tr>
<td align="center" colspan="1">Gate Check 2</td>
<td align="center" colspan="1">5</td>
</tr>

<tr>
<td align="center" colspan="1">Required Functionality</td>
<td align="center" colspan="1">35</td>
</tr>

<tr>
<td align="center" colspan="1">A Functionality</td>
<td align="center" colspan="1">15</td>
</tr>
<tr>
<td align="center" colspan="1">Use of Git / Bitbucket</td>
<td align="center" colspan="1">5</td>
</tr>
<tr>
<td align="center" colspan="1">Code Style</td>
<td align="center" colspan="1">10</td>
</tr>
<tr>
<td align="center" colspan="1">README</td>
<td align="center" colspan="1">25</td>
</tr>
<tr>
<td align="center" colspan="1"><strong>Total</strong></td>
<td align="center" colspan="1"><strong>100</strong></td>
</tr>
</tbody>
</table>


        </div>
    </body>
</html>

