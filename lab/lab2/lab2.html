
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>ECE383</title>
        <meta name="description" content="ECE 383 - Embedded Systems II with the Digilent Atlys at the United States Air Force Academy (USAFA).  Covers VHDL.  Free and open FPGA course.">
        <meta name="author" content="Todd Branchflower">
        <link rel='stylesheet' type='text/css' href='//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css'>
        <script src='//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js'></script>
		<META HTTP-EQUIV="refresh" CONTENT="600"> <!--added this line to force page refresh every 600 seconds-->
    </head>
    <body>

        <div class = "container">
            <div class = "navbar navbar-inverse">
                <div class = "navbar-inner">
                    <a class = "brand" href="../../index.html">ECE383</a>
                    <ul class="nav pull-right">
                        <li><a href="../lab1/lab1.html">&ltPrev</a></li>
                        <li><a href="../lab3/lab3.html">Next&gt</a></li>
                    </ul>
                </div>
            </div>

<table class="table table-striped table-bordered table-condensed">
<tr><td>Start date:</td>	<td>February 7/8</td></tr>
<tr><td>End date:</td>		<td>February 15/16</td></tr>
<tr><td>Lab:</td>		<td>2</td></tr>
<tr><td>Status			<td bgcolor = #D0FFD0>Complete <!--<td bgcolor = #FFFFF0>Not Started--> <!--<td bgcolor = #FFD0D0>In Progress -->
<!--<tr><td>Lab 2 Cutsheet<td><a href="./ECE_383_Lab2_Cutsheet.pdf">ECE_383_Lab2_Cutsheet.pdf</a>-->
<tr><td>Lab 2 Editable Block Diagram<td><a href="./ECE383_Lab2_Block_Diagram_v6.pptx">ECE383_Lab2_Block_Diagram.pptx</a><br>
										<a href="./lab2_block_diagram.vsdx">lab2_block_diagram.vsdx (Visio file)</a>
<tr><td>Lab 2 Supplemental PowerPoint<td><a href="./ECE_383_Lab2.pptx">ECE_383_Lab2.pptx</a>
</table>



<h1>Lab 2 - Data Acquisition, Storage and Display</h1>

<h2>Lab Overview</h2>
In this lab, we will integrate the video display controller developed
in Lab 1 with the audio codec on the Nexys Video board to build a basic
2-channel oscilloscope.  When complete, your lab should generate an
output similar to the picture below.<br>
<td><img src="./img/complete.jpg"></td> 

<h2>Architecture</h2>
Just like the design of Lab 1, Lab 2 is broken down into 
a bunch of separate modules, shown in the block diagram below.
Some of the components in the block diagram will be given to
you and some you created in Lab 1.  It is important to note
that some of the components and signals associated with this
diagram will not be needed for Lab 2, but have been included because you will need them in Labs 3 and 4.

<br><img src="./img/ECE383_Lab2_Block_Diagram_v6.jpg"><br><br>

Consider the data in the diagram as flowing from left
to right.  You will provide an input signal to the Nexys board via a 3.5mm cable connected to the
blue line-in jack. This signal then passes through an <a href = "http://www.analog.com/media/en/technical-documentation/data-sheets/ADAU1761.pdf"> Analog Devices 
ADAU1761 SigmaDSP Audio Codec</a>.  The ADAU1761 samples
the audio input at 48kHz into separate 18-bit 2's complement left
and right channels. The ADAU1761 then transfers this data to our Artix 7
chip over a serial bus through the 7 signals on the left side of the Lab2 
component. You can read more about the audio codec on page 27 of the Nexys Video manual<a href = "https://reference.digilentinc.com/_media/nexys-video/nexysvideo_rm.pdf"> (here)</a>.
<br><br>

The serial protocol coming from the audio codec is quite complex, so you will be given the
Audio Codec Wrapper component as an interface to extract the incoming signal (Audio Codec Wrapper in the Figure above). Whenever new converted data is ready from
the Audio Codec, the ready signal will go high for a single clock cycle. Your circuit will then do two things with the
incoming L_bus_out and R_bus_out signals: First, it will loop both of these signals back
into the Audio Codec so that you can verify (by listening on the green line-out jack)
that the Audio Codec hardware and firmware are operating correctly.  This is
accomplished using the VHDL code below.<br>

<pre>
    process (clk)
    begin
	if (rising_edge(clk)) then
	    if reset_n = '0' then
		L_bus_in <= (others => '0');
		R_bus_in <= (others => '0');				
	    elsif(ready = '1') then
		L_bus_in <= L_bus_out;
		R_bus_in <= R_bus_out;
	    end if;
	end if;
    end process;
</pre>

Second, your circuit will need to send the L_bus_out and R_bus_out signals in an unsigned format to be stored in the block ram (BRAM).
To do this, you will need to convert the 2's  complement values to unsigned.
Performing this conversion is technically easy,
but may be a little difficult to wrap your head around, so let's do some examples. Consider the table below.<br>


<table class="table table-striped table-bordered table-condensed">
<tr><td colspan=2>Input Value		<td colspan=2>Ouput Value
<tr><td>2's complement	<td>2's value	<td>unsigned	<td>unsigned value
<tr><td>100...000	<td>-131072	<td>000...000	<td>0
<tr><td>111...111	<td>-1		<td>011...111	<td>131071
<tr><td>000...000	<td>0		<td>100...000	<td>131072
<tr><td>000...001	<td>1		<td>100...001	<td>131073
<tr><td>011...111	<td>131071	<td>111...111	<td>262143
</table>

The values in the left 2 columns represent the 2's complement number coming out of the Audio Codec, in this case
L_bus_out, while the right 2 columns represent the output of the box labeled
"sign2unsign" in the block diagram.  What we are essentially doing is shifting
the unsigned values up by 131072 (the value which will make all 18-bit numbers positive) so that they all fall into a positive range. 
If you notice the pattern for these 5 number conversions, the lower 17-bits do not change. Only the most-significant-bit changes, 
and it is just inverted.  In the zip file, there is a simple testbench called convert_unsigned_tb.vhdl you can modify to test this math. If you want to "not" the MSB
and then concatenate "&" back the lower 17-bits, I'd recommend doing this as a std_logic_vector.  You can also do this conversion with
the number stored as an unsigned. In this case you can add a special number that keeps the lower 17-bits the same, but inverts the MSB.
If you do this conversion correctly using the testbench, you should get an output simulation plot similar to sim_plot_test_convert.jpg in the zip file.
<br><br>

Here are a couple more pieces of info to help you understand the block diagram above.
Consider the mux with its input going to the WRADDR input of the "BRAM_SDP" block in the block diagram.
This mux circuitry attached to the write address of the BRAM will be used in Lab3,
allowing the microBlaze processor to take over write duties for the RAM (as opposed to an external signal from the Audio Codec).
Independent of the write circuitry, the read circuit pulls data from the RAM,
and draws the waveform.  Unlike for the write circuitry, the read circuitry
requires no FSM control.<br><br>

<h2>Datapath</h2>

Since its a very complex piece of circuitry, the entity for the datapath (LAB2_DP in the block diagram) is
given below.
<br>

<pre>
entity lab2_datapath is
    Port(
	clk : in  STD_LOGIC;
	reset_n : in  STD_LOGIC;
	ac_mclk : out STD_LOGIC;
	ac_adc_sdata : in STD_LOGIC;
	ac_dac_sdata : out STD_LOGIC;
	ac_bclk : out STD_LOGIC;
	ac_lrclk : out STD_LOGIC;
	scl : inout STD_LOGIC;
	sda : inout STD_LOGIC;	
	tmds : out  STD_LOGIC_VECTOR (3 downto 0);
	tmdsb : out  STD_LOGIC_VECTOR (3 downto 0);
	sw: out std_logic_vector(2 downto 0);
	cw: in std_logic_vector (2 downto 0);
	btn: in	STD_LOGIC_VECTOR(4 downto 0);
	switch: in STD_LOGIC_VECTOR(3 downto 0);
	exWrAddr: in std_logic_vector(9 downto 0);
	exWen, exSel: in std_logic;
	Lbus_out, Rbus_out: out std_logic_vector(15 downto 0);
	exLbus, exRbus: in std_logic_vector(15 downto 0);
	flagQ: out std_logic;
	flagClear: in std_logic);
end lab2_datapath;
</pre>

<h2>Flag Register</h2>
In Lab 3, we will be integrating most of the components from this lab with the
MicroBlaze processor (a processor we program onto our FPGA).  In order to make this smooth, we will need a
way to transfer information between the two systems a technique similar to a
2-line handshake.  To make this possible, you will need to build a component
called a flag register. The behavior of the flag register is shown in the table below.
<br>

<table class="table table-striped table-bordered table-condensed">
<tr><td>reset_n	<td>clk		<td>set	<td>clear	<td>Q+
<tr><td>0	<td>X		<td>X	<td>X		<td>0
<tr><td>1	<td>0,1,falling	<td>X	<td>X		<td>Q
<tr><td>1	<td>rising 	<td>0	<td>0		<td>Q
<tr><td>1	<td>rising 	<td>1	<td>0		<td>1
<tr><td>1	<td>rising 	<td>0	<td>1		<td>0
<tr><td>1	<td>rising 	<td>1	<td>1		<td>X
</table>

The 1-bit flag register will interface our lab2 component with a MicroBlaze in lab3
as follows: The LAB2 component will produce some data, put it on a data
line to the MicroBlaze, and then set the flag register using the READY signal. Then, the
MicroBlaze will, at some point, look at the flag register bit. When it
sees that the 'set' bit is 1, the MicroBlaze will grab the data from the register and clear the set bit.
These are just like the flag bits on the 382 ARM processor.


<h2>BRAM</h2>
You need to map the ports of BRAM to include it in your lab2_datapath. The component is declared in the UNIMACRO library - look at that library to
figure out how to port map BRAM.
<pre>
	library UNIMACRO;		-- This contains links to the Xilinx block RAM
	use UNIMACRO.vcomponents.all;
</pre>

<h2>VHDL Code</h2>
The files below will give you a start on Lab 2.
<ul>	
	<li>A package file. Once you insert it in your vivado project, to edit the file, you can find it under Design Sources, expand the VHDL folder, then expand the xil_defaultlib folder, and you can double click lab2_pack.vhdl to edit the file: <a href="./code/lab2_pack.vhdl">lab2_pack.vhdl</a>. I would highly suggest putting all your component declarations here.
	<li>Overall Lab 2 File: <a href="./code/lab2.vhd">lab2.vhd</a>
		<ul>
		<li>Lab 2 Datapath: <a href="./code/lab2_datapath.vhdl">lab2_datapath.vhdl</a> is a template for you to use. This file has BRAM initialization with a dummy signal for the left and right BRAM 
			<li>Audio Codec Wrapper: <a href="./code/Audio_Codec_Wrapper.vhd">Audio_Codec_Wrapper.vhd (Audio Codec Wraper for Xilinx Vivado)</a>
				<ul>
				<li><a href="./code/i2s_ctl.vhd">i2s_ctl.vhd (I2S Transmitter portion of Audio Codec Wraper for Xilinx Vivado)</a>
				<li><a href="./code/audio_init.v">audio_init.v (Audio Initializer portion of Audio Codec Wraper for Xilinx Vivado)</a>
				<li><a href="./code/TWICtl.vhd">TWICtl.vhd (TWI Controller portion of Audio Codec Wraper for Xilinx Vivado)</a>
				<li>You need to add a clocking wizard for the Audio Codec and set the output frequencies to what is required (see comments in the Audio Codec Wrapper file).
				</ul>
			<li>lab2_fsm: <a href="./code/lab2_fsm.vhdl">lab2_fsm.vhdl</a> is a template for you to use.
		</ul>
	<li>Constraint file: <a href="./code/Lab2.xdc">Lab2.xdc </a>
	<li>All this code is in this ZIP file, plus some extra testbenches: <a href="./code/lab2_code_for_cadets.zip">lab2_code_for_cadets.zip </a>
	<!--<li><a href="./code/ac97.vhd">ac97.vhd (for Xilinx ISE)</a>-->
	<!--<li><a href="./code/lab2.ucf">lab2.ucf (for Xilinx ISE)</a>-->
</ul>

<h2>Switches</h2>
<ul>	
	<li> Switch(0):  ch1_enable
	<li> Switch(1):  ch2_enable
	<li> Switch(3):  ex_Sel
	<li> Switch(4):  sim_live
</ul>

<h2>Connections</h2>
	<td><img width="700" src="./img/lab2Connections_v2.jpg"></td>

<h2>Generating Audio Waveforms</h2>
Since you need to use a 3.5mm jack to input signals to the Nexys board, your phone's audio output works quite well.
However, make sure you get an app where you can control both the left and right audio channels individually (i.e. the green and yellow signals in the figure above).
The <a href="http://keuwl.com/FunctionGenerator">Keuwl Dual Channel 
Function Generator</a> (available on Google Play) works well for Android Phones, and is easy to use once you get the hang of it.

<h2>Gate Checks for Required Functionality</h2>
There are 3 gate checks associated with this lab, each worth 5 points - see the rubric below. This year we will use Gradescope to track when you complete the milestones.

<h3>Gate Check 1</h3>
By COB Lesson 13, you must have started a Lab 2 Vivado project and downloaded the template files 
and drop in your Video, VGA, Scopeface, dvid, and tdms files from Lab 1 into your Lab 2 project 
in order to test your Lab 1 Scopeface works when you implement your BRAM using the two initialized
signal examples in BRAM_example_init.vhd. This does not require the audio wrapper (and clockwiz_1) or your control unit is working yet, so you do not need to include these vhdl files in your design yet if you don't want to.
Your Scopeface/Video should continuously be reading the left and right BRAM signals displaying them on the monitor.
You must implement Video entity (from Lab 1) to take the channel output from the left and right BRAMs and send it to the Channel 1 and 2
inputs to be displayed when the readL and readR values equal the row value.  Implement 
this on the hardware and verify that your scopeface is still present and some values are being 
displayed for Channel 1 (at this point the scaling 
may be wrong). 
<br><br>
How do you read from BRAM continuously? From last lesson, to read we need to put the address we want to read on RDADDR, which in this case
is the column requested by video; and when we enable the read RDEN, the BRAM will place the 16-bit data value at this address on DO.
So to continually read, we set RDEN <= '1'.  You can then compare this DO value with the current video's row, and if they are equal, let ch1 <= '1'.


<br><br>
After you demo this, this is a good opportunity to work on scaling the signals 
so their DC value is centered on your grids y-axis.  Note: the DC center value on your scope is row 220, while
if you grabbed the upper ten bits from the BRAM DO, its DC center value will be 512 (a difference of del_x = 512-220 = 292).
  How does this change the comparitor you use to assign ch1 and ch2? (which compares if ReadL = row... 
  does it need to now compare something like if ReadL = row +/- del_x ?)
<br><br>
Notice from the block diagram you will copy your Video instantiation and button processes from Lab 1 
into your Lab 2 Datapath.  You will also have to re-implement the Lab 1 Clocking Wizard in you 
Lab 2 project.  Doing this will eliminate a lot of errors from un-driven output signals on lab 2 top.

Additionally your Scopeface and Button inputs from Lab 1 should be functional as well.

Also, you may need to have implement another Clocking Wizard for the Audio Codec Wrapper inside 
the Datapath entity to get the bit stream to generate. 
<br><br>
The demo can be live to your instructor or an image uploaded to streams.

<h3>Gate Check 2</h3>
NOTE: THIS IS THE HARDEST PART! By COB Lesson 14, you must have implemented and connected the BRAM 
Address Counter to left and right BRAMs, instantiated the Audio Codec Wrapper in Simulation mode (sim_live = '0'),
and your control unit, such that your control unit writes the simulated audio data to the left and right BRAM and
you can see the waveforms plotted on the monitor. (at this point, since there is no trigger, the waveform may or may not be scrolling across the display and the scaling 
may be wrong. The simulated Audio Wrapper is continually sending out 1024 samples, and if your counter (with FSM) are in sync writing 1024 values,
it will be writing the same 1024 values over and over, making the output waveforms on appear stationary. If you want the simulated waveforms
to scroll as if they are not triggered, change your counter rollover to a lesser value like 640... remember there are only
640 columns on scopeface displayed.  Another note about this counter: since your first column on your scopeface is column 20, 
should you initialize the counter at 20?).
<br><br>
How do you write a sample from the audio wrapper to the BRAM? From last lesson, to write we need to: (1) set WE => "11" [not using this feature], (2)
put the address we want to write to on WRADDR, (3) put the converted data sample from the audio wrapper on the 16-bit data input DI, and (3) signal
 write enable WREN = '1' with a CW from your FSM.  Since the address we are writing to in the BRAM is controlled by the counter, your FSM needs to 
 first reset the counter.  Then it should wait for the Ready signal.  When ready goes high, you can then save the sample (let WE = '1' with a CW), then 
increment the counter (with a CW to increment the counter), then compare to see if you are done counting (by checking a SW).  If not done counting, then
jump back to wait for ready, otherwise, start the process over by jumping to the state to reset the counter. 
<br><br>
  Reminder: You must successfully convert the signed audio data 
from the Audio_Codec_Wrapper into unsigned data needed for the monitor. After you demo this, this is a good opportunity to work on scaling the signals 
so their DC value is centered on your grids y-axis and possibly work on the trigger hardware.

If this does not work, you must create a Testbench to help debug why it is not working (see example testbenches in the zip file).

Reminder: implement another Clocking Wizard and the Audio Codec Wrapper inside 
the Datapath entity to get your Audio Codec to begin functioning (if not done in gate check 1). 
<br><br>
The demo can be live to your instructor or an image (if stationary) or video (if scrolling) uploaded to streams.

 <h3>Gate Check 3</h3>
By COB Lesson 16, redo Gate Check 2, except with the Audio Codec Wrapper in Live mode (sim_live = '1'). (at this point, since there is no trigger, the waveform will be scrolling across the display). 
Also make connections to loopback the 
serial ADC input back out to the DAC output (i.e. send the signal back into the Codec). Once you 
implement the design on the board, you can verify functionality by applying an audio signal to the 
audio line in jack (blue) and listening to it on the audio line out jack (Green), and seeing the output on the monitor.

After you finish Gate Check 3, this is a good time to implement proper triggering on the trig_volt value. Besides the hardware to create the SW 
to signal the trigger, you'll also need to add an initial state to "wait for trigger" in your FSM. The rest of the FSM is basically the same.

If this does not work, you must create a Testbench to help debug why it is not working.
<br><br>
The demo can be live to your instructor or a video uploaded to streams.


<h2>Required Functionality</h2>
Get a single channel of the oscilloscope to display with
reliable triggering that holds the waveform at a single
point on the left edge of the display (like having a fixed trigger_volt).  A 220Hz waveform
should display something similar to what is shown in the screenshot at the top of this page. 
Additionally, you must have the following done:

<ul>	<li><del>Use a package file to contain all your component declarations.</del>
	<li>The waveform displayed should be centered about the center of the grid (row 220)
	<li>Use separate datapath and control unit.
	<li>The Mini-C design technique can be used but is NOT required.  However, your instructor will expect you create Lab2_cu using the state machine coding style used
in Lesson 9, with a process for state transitions, separated from a CSA LUT section for generating the output CWs.
	<li>Your datapath must use processes which are similar
	to our basic building block (counter, register, mux, etc.).
	I do not want to see one massive process that attempts
	to do all the work in the datapath.
	<li><del>Testbench for the flagRegister.</del>
	<li><del>Testbench for the control unit.</del>
	<li><del>Testbench for the datapath unit showing data (different value than 
	what is given in the testbench) coming out of the audio codec and being 
	converted from signed to unsigned and then to std_logic_vector to go into your BRAM.
	Include calculations to back up what the waveform shows.</del>
	<li><del>For Bonus Points:  Testbench for the datapath unit showing that same data coming out of the BRAM.  
	Make sure you show the read address and the data values coming out.  This will require you to set your 
	control words on the testbench.  Additionally, you will have to drive the pixel_clock on the Video Module.
	Once you get the datapath testbench running you will notice that DCM module doesn't put out a clock in the 
	Video Module. </del> 
</ul>
<br><br>
The demo can be live to your instructor or a video uploaded to streams.

<h2>B-level functionality</h2>
<ul>
	<li>You can swap the A and B functionality order if you like
	<li>Meet all the requirements of required functionality	
	<li>Add a second channel (in green).
	<li>Include the flag register and exSel (and other ex___ signals) with their muxes as shown in the block diagram

</ul>
<br><br>
The demo can be live to your instructor or a video uploaded to streams.

<h2>A-level functionality</h2>
<ul>
	<li>Meet all the requirements of B-level functionality.
	<li>Use the trigger voltage marker to establish the actual trigger voltage used to capture the waveform.  
	As the trigger is moved up and down, you should see the point at which the waveform
	intersects the left side of the screen change. The trigger arrow marker must be calibrated 
	with the start of the waveform at column 20
	<li>Integrate the button debouncing strategy in HW #7 (or an equivalent debouncing method) to debounce 
	the buttons controlling the trigger time and trigger voltage.
	<li>Move the trigger volt and trigger time cursors on the screen using the buttons.
</ul>
<br><br>
The demo can be live to your instructor or a video uploaded to streams.


<h2>Turn In</h2>
All your work in this lab is to be submitted using Bitbucket and you will make submission in Gradescope to record the time each milestone is completed. 
The main part of the lab is your README, documenting your design. The README can be in markdown, word, or a pdf, and should be uploaded to bitbucket. 
Your README must include the following:

<ul>
<li><strong>Introduction</strong> - Provide a brief overview of the 
problem.</li>

<li><strong>Design/Implementation</strong> - Provide block-diagram of your 
solution using the <strong>signal names in your code</strong>.  The
block diagram given above is somewhat incomplete, so make sure to include corrections to it.
Also, include a state transition diagram for your Lab2_cu.
<br>
Note: the Mini-C design technique can be used but is NOT required.  However, your instructor will expect you create Lab2_cu using the state machine coding style used
in Lesson 9, with a process for state transitions, separated from a CSA LUT section for generating the output CWs. 
<br>
For each module that you built, explain
its overall purpose, inputs, outputs, and behavior. Include all your
vhdl files (code and testbench), wcfg file, and bit files.  Put these
in a folder called "code".</li>

<li><strong>Test/Debug</strong> - Briefly describe the methods used 
to verify system functionality. Include/discuss any testbench simulation plots you used.
<ul type="a">
</ul>

List the major problems you encountered and how you fixed them.  
This should cover all the problems you encountered in the lab and 
how you fixed them.  Break each problem and solution into separate 
paragraphs.</li>

<li><del><strong>Capability</strong> - Well you have built a oscilloscope, what
are its capabilities?</del> 
<ol>	<li><del>The horizontal axis represents time. There are 10 major 
	divisions on the display; how long does each major division represent?</del>  
	<li><del>Each major time division is split into 4 minor division, how long 
	does each minor division represent?</del>

	<li><del>Generate a sine wave that can be fully captured on your display
	(like the yellow channel in the image at the top of this web page).
	record its height in major and minor vertical divisions.  Measure
	this same audio output using the break out audio cable.  Record the 
	peak-to-peak voltage.  Compute the number of volts in each major and
	minor vertical division.</del>

	<li><del>Starting at address 0, how long does it take to fill the entire 
	memory with audio samples (coming in at 48kHz)?</del>

	<li><del>How long does it take to completely draw the display once?</del>  

	<li><del>The question is likely relevant to Lab 3 - how long is the
	vsynch signal held low?</del>
</ol>

<li><strong>Results</strong> - This section should clearly
state for each milestone/functionality the date/time it was achieved, level of achievement 
(e.g, achieved, partially-achieved, not achieved), what was achieved, and how you proved it 
(via demo or evidence like images/videos).  
For example, you could have a table like this:

<table class="table table-striped table-bordered">
<thead>
<tr>
<th align="center">Milestone</th>
<th align="center">Date/Time</th>
<th align="center">What was achieved</th>
</tr>
</thead>
<tbody>

<tr>
<td align="center" colspan="1">Gate Check 1</td>
<td align="center" colspan="1"></td>
<td align="center" colspan="1">Achieved: demonstrated lab#1 worked with the two test signals in the BRAM displayed on scopeface monitor and buttons working</td>
</tr>

<tr>
<td align="center" colspan="1">Gate Check 2</td>
<td align="center" colspan="1"></td>
<td align="center" colspan="1">Achieved: Not demo'd to instructor. See video show the two simulated audio signals scrolling on monitor (not triggered)</td>
</tr>

<tr>
<td align="center" colspan="1">Gate Check 3</td>
<td align="center" colspan="1"></td>
<td align="center" colspan="1">Achieved: demo'd to instructor audio loopback test and the live audio waves scrolling on monitor </td>
</tr>

<tr>
<td align="center" colspan="1">Required Functionality</td>
<td align="center" colspan="1"></td>
<td align="center" colspan="1">Achieved, demo'd to instructor that audio waveform properly triggers at a set point on the display (not using trig_volt buttons). Code has separate FSM and datapath as required.</td>
</tr>
<tr>
<td align="center" colspan="1">B Functionality</td>
<td align="center" colspan="1"></td>
<td align="center" colspan="1">Partially Achieved: demo'd to instructor the 2nd channel working (see B_funct.jpg, showing sine wave on ch1 and triangle wave on ch2), however, never got the buttons to properly debounce.</td>
</tr>
<tr>
<td align="center" colspan="1">A Functionality</td>
<td align="center" colspan="1"></td>
<td align="center" colspan="1">Not Achieved</td>
</tr>
</tbody>
</table>


</li>

<li><strong>Conclusion</strong> - Explain what your learned from this 
lab and what changes you would recommend in future years to this lab 
or the lectures leading up to this lab.</li>
</ul>


<h2>Grading</h2>
<table class="table table-striped table-bordered">
<thead>
<tr>
<th align="center">Item</th>
<th align="center">Points</th>
</tr>
</thead>
<tbody>

<tr>
<td align="center" colspan="1">Gate Check 1</td>
<td align="center" colspan="1">5</td>
</tr>

<tr>
<td align="center" colspan="1">Gate Check 2</td>
<td align="center" colspan="1">5</td>
</tr>

<tr>
<td align="center" colspan="1">Gate Check 3</td>
<td align="center" colspan="1">5</td>
</tr>

<tr>
<td align="center" colspan="1">Required Functionality</td>
<td align="center" colspan="1">30</td>
</tr>

<tr>
<td align="center" colspan="1">B Functionality</td>
<td align="center" colspan="1">10</td>
</tr>

<tr>
<td align="center" colspan="1">A Functionality</td>
<td align="center" colspan="1">10</td>
</tr>
<tr>
<td align="center" colspan="1">Use of Git / Bitbucket</td>
<td align="center" colspan="1">5</td>
</tr>
<tr>
<td align="center" colspan="1">Code Style</td>
<td align="center" colspan="1">10</td>
</tr>
<tr>
<td align="center" colspan="1">README</td>
<td align="center" colspan="1">20</td>
</tr>
<tr>
<td align="center" colspan="1"><strong>Total</strong></td>
<td align="center" colspan="1"><strong>100</strong></td>
</tr>
</tbody>
</table>


    </body>
</html>


