<!DOCTYPE html>
<html lang="en">
<!----- http://getbootstrap.com/css/ ----->
    <head>
        <title>ECE 383 - Lecture Notes</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="ECE 383- Embedded Systems II">
        <meta name="author" content="Capt Jeff Falkinburg">
        <link rel='stylesheet' type='text/css' href='//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css'>
        <script src='//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js'></script>
		<META HTTP-EQUIV="refresh" CONTENT="120"> <!--added this line to force page refresh every 120 seconds-->
    </head>

<body>
        <div class = "container">
            <div class = "navbar navbar-inverse">
                <div class = "navbar-inner">
                    <a class = "brand" href="../index.html">ECE 383</a>
                    <ul class = "nav">
                        <li><a href="../index.html">Home</a></li>
                    </ul>
                    <ul class="nav pull-right">
                        <li><a href="./lecture26.html">&ltPrev</a></li>
                        <li><a href="./lecture30.html">Next&gt</a></li>
                    </ul>

                    </ul>
                </div>
            </div>

<table class="table table-striped table-bordered table-condensed">
<tr><td>Date:</td>	<td>April 14</td></tr>
<tr><td>Lecture:</td>	<td>30</td></tr>
<tr><td>Status:</td>    <td bgcolor = #FFFFF0>Not Started </td><!--<td bgcolor = #FFD0D0>In Progress </td>--> <!--<td bgcolor = #D0FFD0>Complete </td>--></tr>
</table>


<H1>Xilinx Spartan-6 architecture</H1>
The spartan 6 consists of Logic Blocks, block RAM, DSP blocks,
and a global routing network.  We will spend most of our time
discussing the Logic Blocks.  But before we do, a note about
the Xilinx design paradigm.  Modern reconfigurable logic exists
because logic designs can be easily expressed in terms of medium
scale logic building blocks  like registers, shift registers,
multiplexers, counters, adders/subtractors, comparators.  Consider
the following output from ISE during the synthesis of my Lab 4
design.

<pre>
=================================================================
HDL Synthesis Report
Macro Statistics
# Multipliers                                          : 1
 16x16-bit multiplier                                  : 1
# Adders/Subtractors                                   : 9
 13-bit adder                                          : 1
 16-bit adder                                          : 1
 16-bit addsub                                         : 2
 16-bit subtractor                                     : 1
 5-bit subtractor                                      : 3
 8-bit adder                                           : 1
# Registers                                            : 21
 1-bit register                                        : 6
 13-bit register                                       : 1
 16-bit register                                       : 6
 20-bit register                                       : 6
 32-bit register                                       : 1
 8-bit register                                        : 1
# Comparators                                          : 14
 8-bit comparator greater                              : 2
 8-bit comparator lessequal                            : 12
# Multiplexers                                         : 13
 1-bit 2-to-1 multiplexer                              : 4
 1-bit 20-to-1 multiplexer                             : 3
 16-bit 2-to-1 multiplexer                             : 2
 20-bit 2-to-1 multiplexer                             : 4
# FSMs                                                 : 2
</pre>

The software decomposed my design down into these basic building
blocks.  This is one reason that I insisted on certain coding
practices - they increase the likelihood that your designs will
be efficiently mapped into these basic building blocks.  Now consider
the question "What should I include?" when designing an FPGA fabric.
Clearly, you should include logic elements that can efficiently
realize these basic building blocks.  This is precisely what 
Xilinx has done.  To understand how, keep reading.

<h2>Logic Blocks</h2>
Our Spartan 6 has a total of 6,822 logic blocks.  There are three
different "flavors" of logic blocks, SLICEM, SLICEL, and SLICEX
composing 25%, 25% and 50% of the logic blocks respectively. We
will examine the most 

<img src="./img/lecture30-1.gif"><br>
Credit for this figure is given to Xilinx Corp. This is Figure 3 from 
page 9 of the "Spartan-6 FPGA Configurable Logic Block User's Guide"
<br><br>

Each of the 6,000 logic blocks (like that shown above) is connected to
a global routing network.  The inputs to, and outputs from this slice 
are denoted with I/O flags (e.x. A6:A1, AQ).  This slice has three
major subsystems that we will discuss.

<h3>Look-up tables</h3>
Each logic block contains four 64x1 RAMs which are used to 
realize 5 or 6-variable functions; the truth table for the function is 
stored in the RAM and the inputs are used as the addressed.  Lets take
an example, how to realize a full adder using a RAM.   In class we
will derrive the truth table for sum and carry and show how they
can be inserted into a LUT.  Its important for the further development
of the lecture to point out that sum = a xor b xor c and that you can
represent cout = ((a xor b) and cin) or (a and b)  This last form is
pretty nutty, but very useful as we will see in a moment.


<h3>Flip Flops</h3>
There are 8 flip flops in each logic slice. Answer the following questions:
<ul>	<li>Where does the data input from from?
	<li>How are they clocked?
	<li>How are they initialized?
	<li>Where are their outputs sent?
</ul>

<h3>Fast Carry Logic</h3>
The fast carry logic is designed explicitly to realize a variation
of a carry look-ahead adderd.  Consider the construction of a 4-bit
adder with inputs A=a3,a2,a1,a0 B=b3,b2,b1,b0 and a carry in c0. 
Each slice of the adder can either generate a carry bit or 
propagate its carry in to the carry out.

<UL>
<LI>Propagate -- pi is equal to 1 when the inputs to a bit slice are such
	 that any carry in will be propagated. 
<LI>Generate  -- gI is equal to 1 when the inputs to a bit slice are
	 such that a cay will be generated. 
</UL>

We can represent the cout of a slice as cout = g + p*cin  This arrangement
is effectively what is happening in the carry logic block in the middle of
the logic slice.

<h2>Interconnect</h2>
<img src="./img/lecture30-3.gif"><br>
Taken from "Spartan-6 FPGA Configurable Logic Block User Guide", 
page 37, Figure 29.<br><br>

<h2>DSP block</h2>
<img src="./img/lecture30-4.gif"><br>
Taken from "Spartan-6 FPGA DSP48A1 Slice User Guide", page 14, Figure 1-3.

</body>
</html>
